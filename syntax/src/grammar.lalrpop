use pos::Location;
use token::Token;
use ast::{Node, NodeKind, Type, Let, Def, Operator, Toplevel, ToplevelKind};

use MutNodeEnv;

grammar<'input, 'env>(src: &'input str, env: MutNodeEnv<'env>);

extern {
    type Location = Location;

    enum Token<'input> {
        "identifier" => Token::Identifier(<&'input str>),
        "int literal" => Token::IntLiteral(<i64>),
        "float literal" => Token::FloatLiteral(<f64>),
        "true" => Token::True,
        "false" => Token::False,

        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,
        "=" => Token::Equals,

        "==" => Token::EqEq,
        "!=" => Token::Neq,
        "<=" => Token::LE,
        "<" => Token::LT,
        ">=" => Token::GE,
        ">" => Token::GT,

        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,
        "let" => Token::Let,
        "def" => Token::Def,
        "print" => Token::Print,

        ":" => Token::Colon,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,

        ";" => Token::Semi,
        "newline" => Token::ImplicitSemi,
    }
}

Sep = {
    ";",
    "newline",
};

SepSeq<R>: Vec<R> =
    <rs: (<R> Sep)*> <last: R?> => {
        let mut rs = rs;
        rs.extend(last);
        rs
    };

Comma<R>: Vec<R> =
    <rs: (<R> ",")*> <last: R?> => {
        let mut rs = rs;
        rs.extend(last);
        rs
    };

TypeSpec: Type = {
    ":" <name:"identifier"> => {
        Type::new(name.to_string())
    },
    ":" "(" ")" => {
        Type::new("()".to_string())
    },
};

Param: (String, Type) =
    <name:"identifier"> <typ:TypeSpec> => {
        (name.to_string(), typ)
    };

// expressions

IfExpr: Node = {
    "if" <cond:Expression> <then:BlockExpr> => {
        Node::new(env.next_id(), NodeKind::If(Box::new(cond), Box::new(then), None))
    },
    "if" <cond:Expression> <then:BlockExpr> "else" <els:BlockExpr> => {
        Node::new(env.next_id(), NodeKind::If(Box::new(cond), Box::new(then), Some(Box::new(els))))
    },
    "if" <cond:Expression> <then:BlockExpr> "else" <elsif:IfExpr> => {
        Node::new(env.next_id(), NodeKind::If(Box::new(cond), Box::new(then), Some(Box::new(elsif))))
    },
};

WhileExpr: Node =
    "while" <cond:Expression> <body:BlockExpr> => {
        Node::new(env.next_id(), NodeKind::While(Box::new(cond), Box::new(body)))
    };

BlockExpr: Node = {
    "{" <nodes:Nodes> "}" => Node::new(env.next_id(), NodeKind::Block(nodes)),
};

AtomicExpr: Node = {
    "identifier" => Node::new(env.next_id(), NodeKind::Ident(<>.to_string())),
    "print" "(" <expr:Expression> ")" => Node::new(env.next_id(), NodeKind::Print(Box::new(expr))),
    <name:"identifier"> "(" <args:Comma<Expression>> ")" => Node::new(env.next_id(), NodeKind::Call(name.to_string(), args)),
    "int literal" => Node::new(env.next_id(), NodeKind::Int(<>)),
    "float literal" => Node::new(env.next_id(), NodeKind::Float(<>)),
    "true" => Node::new(env.next_id(), NodeKind::Bool(true)),
    "false" => Node::new(env.next_id(), NodeKind::Bool(false)),
    "(" ")" => Node::new(env.next_id(), NodeKind::Unit),
    "(" <expr:Expression> ")" => Node::new(env.next_id(), NodeKind::Parens(Box::new(expr))),
    BlockExpr,
    IfExpr,
    WhileExpr,
};

Factor = {
    <l:Factor> "*" <r:AtomicExpr> => Node::new(env.next_id(), NodeKind::Infix(Box::new(l), Operator::Mul, Box::new(r))),
    <l:Factor> "/" <r:AtomicExpr> => Node::new(env.next_id(), NodeKind::Infix(Box::new(l), Operator::Div, Box::new(r))),
    AtomicExpr,
};

AdditiveOp: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Sub,
};

AdditiveExpr: Node = {
    <l:AdditiveExpr> <op:AdditiveOp> <r:Factor> => Node::new(env.next_id(), NodeKind::Infix(Box::new(l), op, Box::new(r))),
    Factor,
};

CompareOp: Operator = {
    "==" => Operator::Eq,
    "!=" => Operator::Neq,
    "<=" => Operator::LE,
    "<" => Operator::LT,
    ">=" => Operator::GE,
    ">" => Operator::GT,
};

ComparativeExpr: Node = {
    <l:AdditiveExpr> <op:CompareOp> <r:AdditiveExpr> =>
        Node::new(env.next_id(), NodeKind::Infix(Box::new(l), op, Box::new(r))),
    AdditiveExpr,
};

Expression: Node = {
    ComparativeExpr,
};

// statement

LetStmt: Node = {
    "let" <name:"identifier"> <typ:TypeSpec?> "=" <value:Expression> => {
        let let_ = Let {
            name: name.to_string(),
            typ: typ,
            value: value,
        };
        Node::new(env.next_id(), NodeKind::Let(Box::new(let_)))
    },
};

Assignment: Node = {
    <name:"identifier"> "=" <value:Expression> => {
        Node::new(env.next_id(), NodeKind::Assign(name.to_string(), Box::new(value)))
    }
};

Statement: Node = {
    LetStmt,
    Assignment,
};

// definition

Def: Def= {
    "def" <name:"identifier"> "(" <args:Comma<Param>> ")" <ret:TypeSpec?> "{" <body:Nodes> "}" => {
        Def {
            name: name.to_string(),
            args: args,
            ret: ret,
            body: body,
        }
    },
};

Definition: Node =
    Def => Node::new(env.next_id(), NodeKind::Def(Box::new(<>)))
    ;


// nodes

AnyNode: Node = {
    Definition,
    Statement,
    Expression,
};

Nodes: Vec<Node> = SepSeq<AnyNode>;

// toplevels

ToplevelLet: ToplevelKind = {
    "let" <name:"identifier"> <typ:TypeSpec> "=" <value:Expression> => {
        let let_ = Let {
            name: name.to_string(),
            typ: Some(typ),
            value: value,
        };
        ToplevelKind::Let(Box::new(let_))
    },
};

ToplevelKind: ToplevelKind = {
    Def => ToplevelKind::Def(Box::new(<>)),
    ToplevelLet,
    Expression => ToplevelKind::Expr(Box::new(<>)),
};

pub Toplevel = Nodes;
