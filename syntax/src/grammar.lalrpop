use basis::sourcemap::{Spanned, Span, Source, Pos};

use token::Token;
use ast::{Node, NodeKind, Type, Let, Param, Def, Operator, Toplevel, ToplevelKind};

grammar<'input>(input: &'input Source);

extern {
    type Location = Pos;

    enum Token<'input> {
        "upper identifier" => Token::UpperIdentifier(<&'input str>),
        "Ref" => Token::RefType,
        "identifier" => Token::Identifier(<&'input str>),
        "int literal" => Token::IntLiteral(<i32>),
        "float literal" => Token::FloatLiteral(<f64>),
        "true" => Token::True,
        "false" => Token::False,

        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,
        "=" => Token::Equals,

        "==" => Token::EqEq,
        "!=" => Token::Neq,
        "<=" => Token::LE,
        "<" => Token::LT,
        ">=" => Token::GE,
        ">" => Token::GT,

        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,
        "let" => Token::Let,
        "def" => Token::Def,
        "ref" => Token::Ref,
        "@" => Token::Deref,
        "<-" => Token::LeftArrow,

        ":" => Token::Colon,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBrack,
        "]" => Token::RBrack,
        "{" => Token::LBrace,
        "}" => Token::RBrace,

        ";" => Token::Semi,
        "newline" => Token::ImplicitSemi,
    }
}

Span<T>: Spanned<T> = {
    <l: @L> <t: T> <r: @R> => { Spanned::new(l, r, t) }
};

Sep = {
    ";",
    "newline",
};

SepSeq<R>: Vec<R> =
    <rs: (<R> Sep)*> <last: R?> => {
        let mut rs = rs;
        rs.extend(last);
        rs
    };

Comma<R>: Vec<R> =
    <rs: (<R> ",")*> <last: R?> => {
        let mut rs = rs;
        rs.extend(last);
        rs
    };

TypeSpec: Type = {
    ":" <typ:Type> => {
        typ
    }
};

Param: Param =
    <l:@L> <name:"identifier"> <typ:TypeSpec> <r:@R> => {
        Param {
            span: Span::new(l, r),
            name: name.to_string(),
            typ: typ,
        }
    };

// types

PrimaryType: Type = {
    "upper identifier" => Type::new(<>.to_string()),
    "(" ")" => Type::new("()".to_string()),
};

RefType: Type = {
    "Ref" "[" <inner:Type> "]" => Type::newref(inner),
};

Type: Type = {
    PrimaryType,
    RefType,
};

// expressions

IfExpr_: NodeKind = {
    "if" <cond:Expression> <then:BlockExpr> => {
        NodeKind::If(Box::new(cond), Box::new(then), None)
    },
    "if" <cond:Expression> <then:BlockExpr> "else" <els:BlockExpr> => {
        NodeKind::If(Box::new(cond), Box::new(then), Some(Box::new(els)))
    },
    "if" <cond:Expression> <then:BlockExpr> "else" <elsif:IfExpr> => {
        NodeKind::If(Box::new(cond), Box::new(then), Some(Box::new(elsif)))
    },
};

IfExpr: Node = Span<IfExpr_> => { <>.into() };

WhileExpr_: NodeKind =
    "while" <cond:Expression> <body:BlockExpr> => {
        NodeKind::While(Box::new(cond), Box::new(body))
    };

WhileExpr: Node = Span<WhileExpr_> => { <>.into() };

BlockExpr_: NodeKind = {
    "{" <nodes:Nodes> "}" => NodeKind::Block(nodes),
};

BlockExpr: Node = Span<BlockExpr_> => { <>.into() };

Literal_: NodeKind = {
    <ident:"identifier"> => NodeKind::Ident(ident.to_string()),
    <v:"int literal"> => NodeKind::Int(v),
    <v:"float literal"> => NodeKind::Float(v),
    <v:"true"> => NodeKind::Bool(true),
    <v:"false"> => NodeKind::Bool(false),
    "(" ")" => NodeKind::Unit,
};

Literal: Node = Span<Literal_> => { <>.into() };

AtomicExpr: Node = {
    <l:@L> "ref" "(" <expr:Expression> ")" <r:@R> =>
        Node { span: Span::new(l, r), kind: NodeKind::Ref(Box::new(expr)) },
    <l:@L> <name:"identifier"> "(" <args:Comma<Expression>> ")" <r:@R> =>
        Node { span: Span::new(l, r), kind: NodeKind::Call(name.to_string(), args) },
    <l:@L> "(" <expr:Expression> ")" <r:@R> =>
        Node { span: Span::new(l, r), kind: NodeKind::Parens(Box::new(expr)) },
    <l:@L> "@" <expr:AtomicExpr> <r:@R> =>
        Node { span: Span::new(l, r), kind: NodeKind::Deref(Box::new(expr)) },

    Literal,
    BlockExpr,
    IfExpr,
    WhileExpr,
};

Factor: Node = {
    <l:@L> <lhs:Factor> "*" <rhs:AtomicExpr> <r:@R> =>
        Node { span: Span::new(l, r), kind: NodeKind::Infix(Box::new(lhs), Operator::Mul, Box::new(rhs)) },
    <l:@L> <lhs:Factor> "/" <rhs:AtomicExpr> <r:@R> =>
        Node { span: Span::new(l, r), kind: NodeKind::Infix(Box::new(lhs), Operator::Div, Box::new(rhs)) },
    AtomicExpr,
};

AdditiveOp: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Sub,
};

AdditiveExpr: Node = {
    <l:@L> <lhs:AdditiveExpr> <op:AdditiveOp> <rhs:Factor> <r:@R> =>
        Node { span: Span::new(l, r), kind: NodeKind::Infix(Box::new(lhs), op, Box::new(rhs)) },
    Factor,
};

CompareOp: Operator = {
    "==" => Operator::Eq,
    "!=" => Operator::Neq,
    "<=" => Operator::LE,
    "<" => Operator::LT,
    ">=" => Operator::GE,
    ">" => Operator::GT,
};

ComparativeExpr: Node = {
    <l:@L> <lhs:AdditiveExpr> <op:CompareOp> <rhs:AdditiveExpr> <r:@R> =>
        Node { span: Span::new(l, r), kind: NodeKind::Infix(Box::new(lhs), op, Box::new(rhs)) },
    AdditiveExpr,
};

Expression: Node = {
    ComparativeExpr,
};

// statement

LetStmt: Node = {
    <l:@L> "let" <name:"identifier"> <typ:Span<TypeSpec>?> "=" <value:Expression> <r:@R> => {
        let let_ = Let {
            name: name.to_string(),
            typ: typ,
            value: value,
        };
        Node { span: Span::new(l, r), kind: NodeKind::Let(Box::new(let_)) }
    },
};

Assignment: Node = {
    <l:@L> <reference:AtomicExpr> "<-" <value:Expression> <r:@R> => {
        Node { span: Span::new(l, r), kind: NodeKind::Assign(Box::new(reference), Box::new(value)) }
    }
};

Statement: Node = {
    LetStmt,
    Assignment,
};

// definition

Def: Def = {
    "def" <name:"identifier"> "(" <params:Comma<Param>> ")" <ret:TypeSpec?> "=" <body:Expression> => {
        Def {
            name: name.to_string(),
            params: params,
            ret: ret,
            body: body,
        }
    },
};

// nodes

AnyNode: Node = {
    Statement,
    Expression,
};

Nodes: Vec<Node> = SepSeq<AnyNode>;

// toplevels

ToplevelLet: ToplevelKind = {
    "let" <name:"identifier"> <typ:Span<TypeSpec>> "=" <value:Expression> => {
        let let_ = Let {
            name: name.to_string(),
            typ: Some(typ),
            value: value,
        };
        ToplevelKind::Let(Box::new(let_))
    },
};

ToplevelKind: ToplevelKind = {
    Def => ToplevelKind::Def(Box::new(<>)),
    ToplevelLet,
};

Toplevel: Toplevel =
    <l:@L> <kind:ToplevelKind> <r:@R> => Toplevel { span: Span::new(l, r), kind: kind }
    ;

pub Program = SepSeq<Toplevel>;
