use pos::{Spanned, Location};
use token::Token;
use ast::{Node, NodeKind, Type, Let, Def, Operator, Toplevel, ToplevelKind};

use MutNodeEnv;

grammar<'input, 'env>(src: &'input str, env: MutNodeEnv<'env>);

extern {
    type Location = Location;

    enum Token<'input> {
        "identifier" => Token::Identifier(<&'input str>),
        "int literal" => Token::IntLiteral(<i32>),
        "float literal" => Token::FloatLiteral(<f64>),
        "true" => Token::True,
        "false" => Token::False,

        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,
        "=" => Token::Equals,

        "==" => Token::EqEq,
        "!=" => Token::Neq,
        "<=" => Token::LE,
        "<" => Token::LT,
        ">=" => Token::GE,
        ">" => Token::GT,

        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,
        "let" => Token::Let,
        "def" => Token::Def,
        "print" => Token::Print,

        ":" => Token::Colon,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,

        ";" => Token::Semi,
        "newline" => Token::ImplicitSemi,
    }
}

spanned<T>: Spanned<T> = {
    <l: @L> <t: T> <r: @R> => { Spanned::new(l, r, t) }
};

Sep = {
    ";",
    "newline",
};

SepSeq<R>: Vec<R> =
    <rs: (<R> Sep)*> <last: R?> => {
        let mut rs = rs;
        rs.extend(last);
        rs
    };

Comma<R>: Vec<R> =
    <rs: (<R> ",")*> <last: R?> => {
        let mut rs = rs;
        rs.extend(last);
        rs
    };

TypeSpec: Type = {
    ":" <name:"identifier"> => {
        Type::new(name.to_string())
    },
    ":" "(" ")" => {
        Type::new("()".to_string())
    },
};

Param: (String, Type) =
    <name:"identifier"> <typ:TypeSpec> => {
        (name.to_string(), typ)
    };

// expressions

IfExpr: Spanned<Node> = {
    <l:@L> "if" <cond:Expression> <then:BlockExpr> <r:@R> => {
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::If(Box::new(cond), Box::new(then), None)))
    },
    <l:@L> "if" <cond:Expression> <then:BlockExpr> "else" <els:BlockExpr> <r:@R> => {
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::If(Box::new(cond), Box::new(then), Some(Box::new(els)))))
    },
    <l:@L> "if" <cond:Expression> <then:BlockExpr> "else" <elsif:IfExpr> <r:@R> => {
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::If(Box::new(cond), Box::new(then), Some(Box::new(elsif)))))
    },
};

WhileExpr: Spanned<Node> =
    <l:@L> "while" <cond:Expression> <body:BlockExpr> <r:@R> => {
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::While(Box::new(cond), Box::new(body))))
    };

BlockExpr: Spanned<Node> = {
    <l:@L> "{" <nodes:Nodes> "}" <r:@R> => Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Block(nodes))),
};

AtomicExpr: Spanned<Node> = {
    <l:@L> <ident:"identifier"> <r:@R> => Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Ident(ident.to_string()))),
    <l:@L> "print" "(" <expr:Expression> ")" <r:@R> =>
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Print(Box::new(expr)))),
    <l:@L> <name:"identifier"> "(" <args:Comma<Expression>> ")" <r:@R> =>
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Call(name.to_string(), args))),
    <l:@L> <v:"int literal"> <r:@R> => Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Int(v))),
    <l:@L> <v:"float literal"> <r:@R> => Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Float(v))),
    <l:@L> <v:"true"> <r:@R> => Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Bool(true))),
    <l:@L> <v:"false"> <r:@R> => Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Bool(false))),
    <l:@L> "(" ")" <r:@R> => Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Unit)),
    <l:@L> "(" <expr:Expression> ")" <r:@R> => Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Parens(Box::new(expr)))),
    BlockExpr,
    IfExpr,
    WhileExpr,
};

Factor: Spanned<Node> = {
    <l:@L> <lhs:Factor> "*" <rhs:AtomicExpr> <r:@R> =>
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Infix(Box::new(lhs), Operator::Mul, Box::new(rhs)))),
    <l:@L> <lhs:Factor> "/" <rhs:AtomicExpr> <r:@R> =>
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Infix(Box::new(lhs), Operator::Div, Box::new(rhs)))),
    AtomicExpr,
};

AdditiveOp: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Sub,
};

AdditiveExpr: Spanned<Node> = {
    <l:@L> <lhs:AdditiveExpr> <op:AdditiveOp> <rhs:Factor> <r:@R> =>
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Infix(Box::new(lhs), op, Box::new(rhs)))),
    Factor,
};

CompareOp: Operator = {
    "==" => Operator::Eq,
    "!=" => Operator::Neq,
    "<=" => Operator::LE,
    "<" => Operator::LT,
    ">=" => Operator::GE,
    ">" => Operator::GT,
};

ComparativeExpr: Spanned<Node> = {
    <l:@L> <lhs:AdditiveExpr> <op:CompareOp> <rhs:AdditiveExpr> <r:@R> =>
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Infix(Box::new(lhs), op, Box::new(rhs)))),
    AdditiveExpr,
};

Expression: Spanned<Node> = {
    ComparativeExpr,
};

// statement

LetStmt: Spanned<Node> = {
    <l:@L> "let" <name:"identifier"> <typ:spanned<TypeSpec>?> "=" <value:Expression> <r:@R> => {
        let let_ = Let {
            name: name.to_string(),
            typ: typ,
            value: value,
        };
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Let(Box::new(let_))))
    },
};

Assignment: Spanned<Node> = {
    <l:@L> <name:"identifier"> "=" <value:Expression> <r:@R> => {
        Spanned::new(l, r, Node::new(env.next_id(), NodeKind::Assign(name.to_string(), Box::new(value))))
    }
};

Statement: Spanned<Node> = {
    LetStmt,
    Assignment,
};

// definition

Def: Def = {
    "def" <name:"identifier"> "(" <args:Comma<Param>> ")" <ret:TypeSpec?> "{" <body:Nodes> "}" => {
        Def {
            name: name.to_string(),
            args: args,
            ret: ret,
            body: body,
        }
    },
};

// nodes

AnyNode: Spanned<Node> = {
    Statement,
    Expression,
};

Nodes: Vec<Spanned<Node>> = SepSeq<AnyNode>;

// toplevels

ToplevelLet: ToplevelKind = {
    "let" <name:"identifier"> <typ:spanned<TypeSpec>> "=" <value:Expression> => {
        let let_ = Let {
            name: name.to_string(),
            typ: Some(typ),
            value: value,
        };
        ToplevelKind::Let(Box::new(let_))
    },
};

ToplevelKind: ToplevelKind = {
    Def => ToplevelKind::Def(Box::new(<>)),
    ToplevelLet,
    Expression => ToplevelKind::Expr(Box::new(<>)),
};

Toplevel: Toplevel =
    ToplevelKind => Toplevel::new(env.next_id(),  <>)
    ;

pub Program = SepSeq<spanned<Toplevel>>;
